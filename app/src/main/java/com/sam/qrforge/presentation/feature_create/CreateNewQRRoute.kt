package com.sam.qrforge.presentation.feature_create

import android.content.Intent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.lifecycle.compose.dropUnlessResumed
import androidx.navigation.NavController
import androidx.navigation.NavGraphBuilder
import androidx.navigation.navDeepLink
import androidx.navigation.navigation
import com.sam.qrforge.domain.analytics.AnalyticsEvent
import com.sam.qrforge.domain.analytics.AnalyticsParams
import com.sam.qrforge.domain.analytics.AnalyticsTracker
import com.sam.qrforge.presentation.common.composables.LaunchActivityEventsSideEffect
import com.sam.qrforge.presentation.common.composables.UIEventsSideEffect
import com.sam.qrforge.presentation.common.utils.LocalSharedTransitionVisibilityScopeProvider
import com.sam.qrforge.presentation.feature_create.screens.CreateQRScreen
import com.sam.qrforge.presentation.feature_create.screens.PreviewQRScreen
import com.sam.qrforge.presentation.feature_create.screens.SaveQRScreen
import com.sam.qrforge.presentation.feature_export.ExportQRScreen
import com.sam.qrforge.presentation.feature_export.ExportQRViewModel
import com.sam.qrforge.presentation.navigation.animatedComposable
import com.sam.qrforge.presentation.navigation.fadeAnimatedComposable
import com.sam.qrforge.presentation.navigation.nav_graph.NavDeepLinks
import com.sam.qrforge.presentation.navigation.nav_graph.NavRoutes
import kotlinx.coroutines.flow.merge
import org.koin.compose.koinInject
import org.koin.compose.viewmodel.koinViewModel
import org.koin.compose.viewmodel.sharedKoinViewModel

fun NavGraphBuilder.createNewQRRoute(
	controller: NavController
) = navigation<NavRoutes.CreateRoute>(startDestination = CreateNewQRNavGraph.CreateNewRoute) {

	fadeAnimatedComposable<CreateNewQRNavGraph.CreateNewRoute>(
		deepLinks = listOf(
			navDeepLink {
				this.action = Intent.ACTION_VIEW
				this.uriPattern = NavDeepLinks.CREATE_NEW_QR_DEEP_LINK
			}
		)
	) { backStack ->

		val analytics = koinInject<AnalyticsTracker>()

		LaunchedEffect(Unit) {
			analytics.logEvent(
				AnalyticsEvent.SCREEN_VIEW,
				mapOf(AnalyticsParams.SCREEN_NAME to "generate_qr_screen")
			)
		}

		val viewModel = backStack.sharedKoinViewModel<CreateNewQRViewModel>(controller)
		val currentContent by viewModel.qrContent.collectAsStateWithLifecycle()

		UIEventsSideEffect(events = viewModel::uiEvents)

		CompositionLocalProvider(LocalSharedTransitionVisibilityScopeProvider provides this) {
			CreateQRScreen(
				content = currentContent,
				onEvent = viewModel::onCreateEvents,
				onPreviewQR = dropUnlessResumed {
					controller.navigate(CreateNewQRNavGraph.PreviewNewRoute)
				},
				navigation = {
					if (controller.previousBackStackEntry != null)
						IconButton(onClick = dropUnlessResumed { controller.popBackStack() }) {
							Icon(
								imageVector = Icons.AutoMirrored.Filled.ArrowBack,
								contentDescription = "Back Arrow"
							)
						}
				},
			)
		}
	}

	animatedComposable<CreateNewQRNavGraph.PreviewNewRoute> { backStack ->

		// no analytics for preview screen as this is default after creating a new qr

		val viewModel = backStack.sharedKoinViewModel<CreateNewQRViewModel>(controller)
		val generated by viewModel.generated.collectAsStateWithLifecycle()
		val content by viewModel.qrContent.collectAsStateWithLifecycle()

		UIEventsSideEffect(events = viewModel::uiEvents)
		LaunchActivityEventsSideEffect(eventsFlow = viewModel::activityEvent)

		CompositionLocalProvider(LocalSharedTransitionVisibilityScopeProvider provides this) {
			PreviewQRScreen(
				generated = generated,
				content = content,
				onEvent = viewModel::onCreateEvents,
				onNavigateToSave = dropUnlessResumed {
					controller.navigate(CreateNewQRNavGraph.SaveRoute)
				},
				onNavigateToExport = {
					controller.navigate(CreateNewQRNavGraph.ExportRoute)
				},
				navigation = {
					if (controller.previousBackStackEntry != null)
						IconButton(onClick = dropUnlessResumed { controller.popBackStack() }) {
							Icon(
								imageVector = Icons.AutoMirrored.Filled.ArrowBack,
								contentDescription = "Back Arrow"
							)
						}
				},
			)
		}
	}

	animatedComposable<CreateNewQRNavGraph.SaveRoute> { backStack ->

		val analytics = koinInject<AnalyticsTracker>()

		LaunchedEffect(Unit) {
			analytics.logEvent(
				AnalyticsEvent.SCREEN_VIEW,
				mapOf(AnalyticsParams.SCREEN_NAME to "save_generated_qr_screen")
			)
		}

		val viewModel = backStack.sharedKoinViewModel<CreateNewQRViewModel>(controller)
		val state by viewModel.saveQRState.collectAsStateWithLifecycle()

		UIEventsSideEffect(
			events = viewModel::uiEvents,
			onNavigateBack = dropUnlessResumed { controller.popBackStack<NavRoutes.HomeRoute>(false) },
		)

		CompositionLocalProvider(LocalSharedTransitionVisibilityScopeProvider provides this) {
			SaveQRScreen(
				state = state,
				onEvent = viewModel::onSaveEvent,
				navigation = {
					if (controller.previousBackStackEntry != null)
						IconButton(onClick = dropUnlessResumed { controller.popBackStack() }) {
							Icon(
								imageVector = Icons.AutoMirrored.Filled.ArrowBack,
								contentDescription = "Back Arrow"
							)
						}
				},
			)
		}
	}

	animatedComposable<CreateNewQRNavGraph.ExportRoute> { backStack ->

		val analytics = koinInject<AnalyticsTracker>()

		LaunchedEffect(Unit) {
			analytics.logEvent(
				AnalyticsEvent.SCREEN_VIEW,
				mapOf(
					AnalyticsParams.SCREEN_NAME to "export_qr_screen",
					AnalyticsParams.PREVIOUS_SCREEN_NAME to "generate_qr_screen"
				)
			)
		}

		val createViewModel = backStack.sharedKoinViewModel<CreateNewQRViewModel>(controller)
		val generated by createViewModel.generated.collectAsStateWithLifecycle()

		val viewModel = koinViewModel<ExportQRViewModel>()

		val decoration by viewModel.selectedDecoration.collectAsStateWithLifecycle()
		val exportState by viewModel.exportScreenState.collectAsStateWithLifecycle()

		UIEventsSideEffect(
			events = { merge(createViewModel.uiEvents, viewModel.uiEvents) },
			onNavigateBack = dropUnlessResumed { controller.popBackStack() },
		)

		LaunchActivityEventsSideEffect(viewModel::activityEvents)

		CompositionLocalProvider(LocalSharedTransitionVisibilityScopeProvider provides this) {
			ExportQRScreen(
				decoration = decoration,
				state = exportState,
				generatedQR = generated,
				onEvent = viewModel::onEvent,
				navigation = {
					if (controller.previousBackStackEntry != null)
						IconButton(onClick = dropUnlessResumed { controller.popBackStack() }) {
							Icon(
								imageVector = Icons.AutoMirrored.Filled.ArrowBack,
								contentDescription = "Back Arrow"
							)
						}
				},
			)
		}
	}
}